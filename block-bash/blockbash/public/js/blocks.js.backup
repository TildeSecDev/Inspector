let categoryData = {};

fetch('/blocks/categoryData.json')
  .then(response => response.json())
  .then(data => {
    categoryData = data;
}).catch(err => {
    console.error('Error fetching category data:', err);
});

function getBlockCommand(block) {
  // Get the command/tool name
  const type = block.dataset.blockType || '';
  // For custom block (blockType is empty), just return the input value
  if (type === '') {
    const input = block.querySelector('input');
    return input ? input.value.trim() : '';
  }

  // Special handling for known block types
  if (type === 'nmap') {
    const args = block.querySelector('.nmap-args')?.value || '';
    return `nmap ${args}`.trim();
  }
  if (type === 'ping') {
    const host = block.querySelector('.ping-host')?.value || '';
    const timeout = block.querySelector('.ping-timeout')?.value || '';
    return `ping ${host} ${timeout}`.trim();
  }
  if (type === 'ssh') {
    const host = block.querySelector('.ssh-host')?.value || '';
    const user = block.querySelector('.ssh-user')?.value || '';
    const cmd = block.querySelector('.ssh-command')?.value || '';
    let sshStr = 'ssh ';
    if (user && host) sshStr += `${user}@${host}`;
    else if (host) sshStr += host;
    if (cmd) sshStr += ` "${cmd}"`;
    return sshStr.trim();
  }
  if (type === 'curl') {
    const url = block.querySelector('.curl-url')?.value || '';
    const options = block.querySelector('.curl-options')?.value || '';
    return `curl ${options} ${url}`.trim();
  }
  if (type === 'wget') {
    const url = block.querySelector('.wget-url')?.value || '';
    const options = block.querySelector('.wget-options')?.value || '';
    return `wget ${options} ${url}`.trim();
  }
  if (type === 'ftp') {
    const host = block.querySelector('.ftp-host')?.value || '';
    const user = block.querySelector('.ftp-user')?.value || '';
    const pass = block.querySelector('.ftp-pass')?.value || '';
    // For security, don't include password in command string unless needed
    return `ftp ${user ? `-u ${user}` : ''} ${host}`.trim();
  }
  if (type === 'nano') {
    const filename = block.querySelector('.nano-filename')?.value || '';
    return `nano ${filename}`.trim();
  }
  if (type === 'traceroute') {
    const host = block.querySelector('.traceroute-host')?.value || '';
    return `traceroute ${host}`.trim();
  }
  if (type === 'sudo') {
    // Sudo block: wrap all child blocks as sudo commands
    const childBlocks = block.querySelectorAll('.block');
    const childCmds = Array.from(childBlocks).map(getBlockCommand).filter(Boolean);
    return childCmds.map(cmd => `sudo ${cmd}`).join(' && ');
  }
  // Default: join all input values after the blockType
  const inputs = Array.from(block.querySelectorAll('input'))
    .map(input => input.value.trim())
    .filter(val => val);
  return [type, ...inputs].join(' ').trim();
}

// Build a shell command string from all blocks inside the given drop area
function buildCommandStringFromBlocks(dropId = 'drop-area') {
  const container = document.getElementById(dropId);
  if (!container) return '';
  const blocks = Array.from(container.children).filter(el => el.classList.contains('block'));
  const commands = blocks.map(getBlockCommand).filter(Boolean);
  return commands.join(' && ');
}

window.buildCommandStringFromBlocks = buildCommandStringFromBlocks;

document.addEventListener('DOMContentLoaded', () => {
  const dropArea = document.getElementById('drop-area');
  const networkDropArea = document.getElementById('network-drop-area');
  const workspace = document.querySelector('.workspace');
  const minimizeBtn = document.getElementById('btn-console-minimize');
  const peekBtn = document.getElementById('peek-terminal-btn');
  let term = window.term; // xterm.js instance must be globally available as window.term

  console.log('[Blocks] DOM loaded, dropArea found:', !!dropArea, 'networkDropArea found:', !!networkDropArea);

  // Show welcome message at startup
  function showWelcome() {
    if (term) {
      term.clear();
      term.write("\x1b[1;35mWelcome to \x1b[1;34mTildeSec's Inspector Editor!\x1b[0m\r\n");
      term.write('$ ');
    }
  }
  showWelcome();

  // Initialize drag and drop for both areas
  setupDropHandlers(dropArea);
  setupDropHandlers(networkDropArea);

  // Terminal minimize/peek logic - updated for new bottom-panel layout
    e.preventDefault();
    
    // Check if this is a reposition operation
    const transferData = e.dataTransfer.getData('text/plain');
    if (transferData === 'reposition' || document.querySelector('.dragging')) {
      e.dataTransfer.dropEffect = 'move';
    } else {
      e.dataTransfer.dropEffect = 'copy';
    }
  });

  dropArea.addEventListener('drop', (e) => {
    e.preventDefault();
    
    // Remove visual feedback
    dropArea.classList.remove('drag-over');
    
    console.log('[Blocks] Drop event triggered');
    
    try {
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      console.log('[Blocks] Drop data:', data);
      
      const categoryDataColor = categoryData[data.category]?.color || '#888';
      
      // Remove placeholder content when first item is dropped
      const placeholder = dropArea.querySelector('#block-editor-placeholder, #network-editor-placeholder');
      if (placeholder) {
        placeholder.remove();
      }
      
      // Check if this is a network block
      const isNetworkBlock = data.isNetworkBlock || data.deviceType;
      
      const block = document.createElement('div');
      
      if (isNetworkBlock) {
        // Handle network blocks differently
        block.className = `network-device`;
        
        // Calculate precise drop position relative to drop area
        const dropAreaRect = dropArea.getBoundingClientRect();
        const offsetX = e.clientX - dropAreaRect.left - 50; // Center the block
        const offsetY = e.clientY - dropAreaRect.top - 25;
        
        block.style.cssText = `--theme: ${categoryDataColor}; position: absolute; left: ${offsetX}px; top: ${offsetY}px;`;
        block.dataset.deviceType = data.deviceType || 'network-device';
        block.dataset.blockType = data.type;
        
        // Create network device representation with proper icons
        const deviceContainer = document.createElement('div');
        deviceContainer.className = 'device-container';
        
        const deviceIcon = document.createElement('div');
        deviceIcon.className = 'device-icon';
        
        // Set appropriate icons based on device type
        let iconClass = 'fa fa-square';
        switch(data.deviceType) {
          case 'end-device':
            if (data.type.includes('desktop') || data.type.includes('pc')) iconClass = 'fa fa-desktop';
            else if (data.type.includes('laptop')) iconClass = 'fa fa-laptop';
            else if (data.type.includes('server')) iconClass = 'fa fa-server';
            else if (data.type.includes('phone')) iconClass = 'fa fa-phone';
            else if (data.type.includes('tablet')) iconClass = 'fa fa-tablet';
            else if (data.type.includes('smartphone')) iconClass = 'fa fa-mobile';
            break;
          case 'router':
            iconClass = 'fa fa-sitemap';
            break;
          case 'switch':
          case 'layer3-switch':
            iconClass = 'fa fa-th-large';
            break;
          case 'hub':
            iconClass = 'fa fa-circle-o';
            break;
          case 'wireless-router':
          case 'access-point':
          case 'wireless-client':
            iconClass = 'fa fa-wifi';
            break;
          case 'firewall':
          case 'security-appliance':
            iconClass = 'fa fa-shield';
            break;
          case 'hacking-platform':
          case 'exploitation-tool':
          case 'web-testing-tool':
          case 'vulnerability-scanner':
            iconClass = 'fa fa-terminal';
            break;
          case 'iot-device':
          case 'iot-sensor':
          case 'iot-actuator':
            iconClass = 'fa fa-microchip';
            break;
          default:
            iconClass = 'fa fa-square';
        }
        
        deviceIcon.innerHTML = `<i class="${iconClass}"></i>`;
        
        const deviceLabel = document.createElement('div');
        deviceLabel.className = 'device-label';
        deviceLabel.textContent = data.type.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        
        deviceContainer.appendChild(deviceIcon);
        deviceContainer.appendChild(deviceLabel);
        block.appendChild(deviceContainer);
        
        // Add configuration panel (hidden by default)
        const configPanel = document.createElement('div');
        configPanel.className = 'device-config';
        configPanel.style.display = 'none';
        configPanel.innerHTML = data.template;
        block.appendChild(configPanel);
        
        // Double-click to configure
        block.addEventListener('dblclick', () => {
          configPanel.style.display = configPanel.style.display === 'none' ? 'block' : 'none';
        });
        
        // Add info button to network blocks
        const infoBtn = document.createElement('button');
        infoBtn.className = 'block-info-btn';
        infoBtn.innerHTML = 'i';
        infoBtn.title = 'Click for more information';
        infoBtn.onclick = (e) => {
          e.stopPropagation();
          showBlockInfoPopup(block, data);
        };
        block.appendChild(infoBtn);
        
        // Add delete button to network blocks
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.onclick = () => block.remove();
        block.appendChild(deleteBtn);
        
        // Add right-click context menu for network blocks
        block.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showBlockContextMenu(e, block);
        });
        
        // Make network blocks draggable for repositioning
        makeBlockDraggable(block);
        
      } else {
        // Handle regular command blocks - now with free positioning
        block.className = `block`;
        
        // Calculate precise drop position relative to drop area for all blocks
        const dropAreaRect = dropArea.getBoundingClientRect();
        const offsetX = e.clientX - dropAreaRect.left - 50; // Center the block
        const offsetY = e.clientY - dropAreaRect.top - 25;
        
        block.style.cssText = `--theme: ${categoryDataColor}; position: absolute; left: ${offsetX}px; top: ${offsetY}px;`;
        block.dataset.blockType = data.type;
        block.innerHTML = data.template;
        
        // Immediately reveal any input fields for command blocks
        const details = block.querySelector('.block-details');
        if (details) {
          details.style.display = 'flex';
        }
        
        // Add info button to regular blocks
        const infoBtn = document.createElement('button');
        infoBtn.className = 'block-info-btn';
        infoBtn.innerHTML = 'i';
        infoBtn.title = 'Click for more information';
        infoBtn.onclick = (e) => {
          e.stopPropagation();
          showBlockInfoPopup(block, data);
        };
        block.appendChild(infoBtn);
        
        // Add delete button to regular blocks
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.onclick = () => block.remove();
        block.appendChild(deleteBtn);
        
        // Add right-click context menu for regular blocks
        block.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showBlockContextMenu(e, block);
        });
        
        // Make regular blocks draggable for repositioning
        makeBlockDraggable(block);
      }
      
      dropArea.appendChild(block);
      console.log('[Blocks] Block created and added to drop area:', block);
      
    } catch (err) {
      console.error('Error handling drop:', err);
    }
  }); // <-- Correctly close the drop event handler here

  // Initialize drag and drop for both areas
  setupDropHandlers(dropArea);
  setupDropHandlers(networkDropArea);

  // Terminal minimize/peek logic - updated for new bottom-panel layout
  if (minimizeBtn) {
    minimizeBtn.addEventListener('click', () => {
      const consoleElement = document.querySelector('.console');
      const sidebar = document.querySelector('.sidebar');
      const terminalBtn = document.querySelector('.category-btn[data-category="terminal"]');
      
      if (consoleElement && sidebar) {
        // Hide terminal
        consoleElement.classList.add('hidden');
        sidebar.classList.add('terminal-hidden');
        
        // Update terminal button state
        if (terminalBtn) {
          terminalBtn.classList.remove('active');
        }
      }
    });
  }
  
  if (peekBtn) {
    peekBtn.addEventListener('click', () => {
      const consoleElement = document.querySelector('.console');
      const sidebar = document.querySelector('.sidebar');
      const terminalBtn = document.querySelector('.category-btn[data-category="terminal"]');
      
      if (consoleElement && sidebar) {
        // Show terminal
        consoleElement.classList.remove('hidden');
        sidebar.classList.remove('terminal-hidden');
        
        // Update terminal button state
        if (terminalBtn) {
          terminalBtn.classList.add('active');
        }
      }
    });
  }

  // --- Add: Terminal switcher logic ---
  const terminalTabs = document.getElementById('terminal-tabs');
  const addTerminalBtn = document.getElementById('btn-new-terminal');
  let terminals = [{ id: 0, label: 'Terminal 1', element: document.getElementById('output-terminal'), xterm: window.term }];
  let activeTerminal = 0;

  function switchTerminal(idx) {
    terminals.forEach((t, i) => {
      t.element.style.display = (i === idx) ? '' : 'none';
      if (t.xterm) {
        if (i === idx) t.xterm.focus();
      }
    });
    activeTerminal = idx;
  renderTerminalTabs();
}

  // Initialize block repositioning system
  setupBlockRepositioning();
  console.log('[Blocks] Block repositioning system initialized');
});

// Function to setup drag and drop handlers for a drop area
function setupDropHandlers(dropArea) {
  if (!dropArea) return;
  
  // Drag over event for visual feedback
  dropArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    
    // Check if this is a reposition operation
    const transferData = e.dataTransfer.getData('text/plain');
    if (transferData === 'reposition' || document.querySelector('.dragging')) {
      e.dataTransfer.dropEffect = 'move';
    } else {
      e.dataTransfer.dropEffect = 'copy';
    }
  });

  dropArea.addEventListener('drop', (e) => {
    e.preventDefault();
    
    // Remove visual feedback
    dropArea.classList.remove('drag-over');
    
    console.log('[Blocks] Drop event triggered');
    
    try {
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      console.log('[Blocks] Drop data:', data);
      
      const categoryDataColor = categoryData[data.category]?.color || '#888';
      
      // Remove placeholder content when first item is dropped
      const placeholder = dropArea.querySelector('#block-editor-placeholder, #network-editor-placeholder');
      if (placeholder) {
        placeholder.remove();
      }
      
      // Check if this is a network block
      const isNetworkBlock = data.isNetworkBlock || data.deviceType;
      
      const block = document.createElement('div');
      
      if (isNetworkBlock) {
        // Handle network blocks differently
        block.className = `network-device`;
        
        // Calculate precise drop position relative to drop area
        const dropAreaRect = dropArea.getBoundingClientRect();
        const offsetX = e.clientX - dropAreaRect.left - 50; // Center the block
        const offsetY = e.clientY - dropAreaRect.top - 25;
        
        block.style.cssText = `--theme: ${categoryDataColor}; position: absolute; left: ${offsetX}px; top: ${offsetY}px;`;
        block.dataset.deviceType = data.deviceType || 'network-device';
        block.dataset.blockType = data.type;
        
        // Create network device representation with proper icons
        const deviceContainer = document.createElement('div');
        deviceContainer.className = 'device-container';
        
        const deviceIcon = document.createElement('div');
        deviceIcon.className = 'device-icon';
        
        // Set appropriate icons based on device type
        let iconClass = 'fa fa-square';
        switch(data.deviceType) {
          default:
            iconClass = 'fa fa-square';
        }
        
        deviceIcon.innerHTML = `<i class="${iconClass}"></i>`;
        
        const deviceLabel = document.createElement('div');
        deviceLabel.className = 'device-label';
        deviceLabel.textContent = data.type.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        
        deviceContainer.appendChild(deviceIcon);
        deviceContainer.appendChild(deviceLabel);
        block.appendChild(deviceContainer);
        
        // Add configuration panel (hidden by default)
        const configPanel = document.createElement('div');
        configPanel.className = 'device-config';
        configPanel.style.display = 'none';
        configPanel.innerHTML = data.template;
        block.appendChild(configPanel);
        
        // Double-click to configure
        block.addEventListener('dblclick', () => {
          configPanel.style.display = configPanel.style.display === 'none' ? 'block' : 'none';
        });
        
        // Add info button to network blocks
        const infoBtn = document.createElement('button');
        infoBtn.className = 'block-info-btn';
        infoBtn.innerHTML = 'i';
        infoBtn.title = 'Click for more information';
        infoBtn.onclick = (e) => {
          e.stopPropagation();
          showBlockInfoPopup(block, data);
        };
        block.appendChild(infoBtn);
        
        // Add delete button to network blocks
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.onclick = () => block.remove();
        block.appendChild(deleteBtn);
        
        // Add right-click context menu for network blocks
        block.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showBlockContextMenu(e, block);
        });
        
        // Make network blocks draggable for repositioning
        makeBlockDraggable(block);
        
      } else {
        // Handle regular command blocks - now with free positioning
        block.className = `block`;
        
        // Calculate precise drop position relative to drop area for all blocks
        const dropAreaRect = dropArea.getBoundingClientRect();
        const offsetX = e.clientX - dropAreaRect.left - 50; // Center the block
        const offsetY = e.clientY - dropAreaRect.top - 25;
        
        block.style.cssText = `--theme: ${categoryDataColor}; position: absolute; left: ${offsetX}px; top: ${offsetY}px;`;
        block.dataset.blockType = data.type;
        block.innerHTML = data.template;
        
        // Immediately reveal any input fields for command blocks
        const inputs = block.querySelectorAll('input[type="text"], input[type="password"], input[type="number"], input[type="url"], input[type="email"], textarea, select');
        inputs.forEach(input => {
          input.style.display = 'inline-block';
        });
        
        // Add delete button to regular blocks
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.onclick = () => block.remove();
        block.appendChild(deleteBtn);
        
        // Add info button to regular blocks
        const infoBtn = document.createElement('button');
        infoBtn.className = 'block-info-btn';
        infoBtn.innerHTML = 'i';
        infoBtn.title = 'Click for more information';
        infoBtn.onclick = (e) => {
          e.stopPropagation();
          showBlockInfoPopup(block, data);
        };
        block.appendChild(infoBtn);
        
        // Add right-click context menu for regular blocks
        block.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showBlockContextMenu(e, block);
        });
        
        // Make regular blocks draggable for repositioning
        makeBlockDraggable(block);
      }
      
      dropArea.appendChild(block);
      console.log('[Blocks] Block created and added to drop area:', block);
      
    } catch (err) {
      console.error('Error handling drop:', err);
    }
  }); // <-- Correctly close the drop event handler here
}

// Enhanced function to make dropped blocks draggable for free positioning
function makeBlockDraggable(block) {
  if (!block || block.dataset.draggable === "true") return; // Prevent duplicate setup
  
  block.setAttribute('draggable', 'true');
  block.dataset.draggable = "true";
  
  // Add visual cursor indicator
  block.style.cursor = 'move';
  
  let draggedBlock = null;
  let dragOffset = { x: 0, y: 0 };
  
  block.addEventListener('dragstart', function(e) {
    draggedBlock = block;
    
    // Calculate and store offset from mouse to top-left of block
    const rect = block.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    // Store offset on the block for access during drop
    block._dragOffset = dragOffset;
    
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', 'reposition');
    
    // Add visual feedback immediately
    block.classList.add('dragging');
    
    console.log('[Blocks] Started dragging block:', block.dataset.blockType || block.dataset.deviceType, 'offset:', dragOffset);
  });
  
  block.addEventListener('dragend', function(e) {
    block.classList.remove('dragging');
    draggedBlock = null;
    console.log('[Blocks] Finished dragging block');
  });
  
  // Prevent default drag image for smoother experience
  block.addEventListener('dragstart', function(e) {
    const img = new Image();
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
    e.dataTransfer.setDragImage(img, 0, 0);
  });
}

// Enhanced repositioning system - separate from main drop handler
function setupBlockRepositioning() {
  const dropArea = document.getElementById('drop-area');
  if (!dropArea) return;
  
  console.log('[Blocks] Setting up block repositioning system');
  
  // Handle repositioning with a separate drop event listener
  dropArea.addEventListener('drop', (e) => {
    const transferData = e.dataTransfer.getData('text/plain');
    
    // Check if this is a reposition operation
    if (transferData === 'reposition') {
      e.preventDefault();
      e.stopPropagation();
      
      console.log('[Blocks] Handling reposition drop');
      
      // Find the currently dragging block
      const draggedBlock = document.querySelector('.block.dragging, .network-device.dragging');
      if (draggedBlock) {
        // Calculate precise new position using the stored offset
        const dropAreaRect = dropArea.getBoundingClientRect();
        
        // Get the drag offset that was stored during dragstart
        const dragOffset = draggedBlock._dragOffset || { x: 50, y: 25 };
        
        const newX = Math.max(0, e.clientX - dropAreaRect.left - dragOffset.x);
        const newY = Math.max(0, e.clientY - dropAreaRect.top - dragOffset.y);
        
        // Update block position
        draggedBlock.style.left = newX + 'px';
        draggedBlock.style.top = newY + 'px';
        
        console.log('[Blocks] Block repositioned to:', newX, newY);
        return;
      }
    }
  }, true); // Use capture phase to handle before main drop handler
}

// Function to show block info popup
function showBlockInfoPopup(block, data) {
  // Remove any existing popup
  const existingPopup = document.querySelector('.block-info-popup');
  if (existingPopup) {
    existingPopup.remove();
  }
  
  // Get block name and explanation
  const titleElement = block.querySelector('.block-title, .network-block-title');
  const explanationElement = block.querySelector('.explanation');
  
  const blockName = titleElement ? titleElement.textContent : (data.name || data.type || 'Block');
  const explanation = explanationElement ? explanationElement.textContent : 'No description available.';
  
  // Create popup
  const popup = document.createElement('div');
  popup.className = 'block-info-popup';
  popup.innerHTML = `
    <div class="popup-header">
      <h3>${blockName}</h3>
      <button class="popup-close" onclick="this.parentElement.parentElement.remove()">×</button>
    </div>
    <div class="popup-content">
      <p>${explanation}</p>
    </div>
  `;
  
  // Position popup in center of screen
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #333;
    border-radius: 8px;
    padding: 0;
    z-index: 10000;
    max-width: 400px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  `;
  
  document.body.appendChild(popup);
  
  // Close popup when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closePopup(e) {
      if (!popup.contains(e.target)) {
        popup.remove();
        document.removeEventListener('click', closePopup);
      }
    });
  }, 100);
}

// Function to show block context menu
function showBlockContextMenu(e, block) {
  // Remove any existing context menu
  const existingMenu = document.querySelector('.block-context-menu');
  if (existingMenu) {
    existingMenu.remove();
  }
  
  // Create context menu
  const menu = document.createElement('div');
  menu.className = 'block-context-menu';
  menu.innerHTML = `
    <div class="context-menu-item" data-action="delete">Delete Block</div>
    <div class="context-menu-item" data-action="duplicate">Duplicate Block</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" data-action="change-color">Change Color</div>
    <div class="context-menu-item" data-action="resize">Resize</div>
  `;
  
  // Position menu at cursor
  menu.style.cssText = `
    position: fixed;
    left: ${e.pageX}px;
    top: ${e.pageY}px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 10000;
    min-width: 150px;
  `;
  
  document.body.appendChild(menu);
  
  // Add event listeners for menu items
  menu.addEventListener('click', (e) => {
    const action = e.target.getAttribute('data-action');
    if (!action) return;
    
    switch (action) {
      case 'delete':
        block.remove();
        break;
      case 'duplicate':
        duplicateBlock(block);
        break;
      case 'change-color':
        changeBlockColor(block);
        break;
      case 'resize':
        resizeBlock(block);
        break;
    }
    
    menu.remove();
  });
  
  // Close menu when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 100);
}

// Function to duplicate a block
function duplicateBlock(originalBlock) {
  const clone = originalBlock.cloneNode(true);
  
  // Offset the clone position slightly
  if (originalBlock.style.left && originalBlock.style.top) {
    const leftValue = parseInt(originalBlock.style.left) + 20;
    const topValue = parseInt(originalBlock.style.top) + 20;
    clone.style.left = leftValue + 'px';
    clone.style.top = topValue + 'px';
  }
  
  // Re-add event listeners to the clone
  setupBlockEventListeners(clone);
  
  // Make the clone draggable
  makeBlockDraggable(clone);
  
  originalBlock.parentNode.appendChild(clone);
}

// Function to change block color
function changeBlockColor(block) {
  const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
  const currentIndex = colors.findIndex(color => block.style.getPropertyValue('--theme') === color);
  const nextIndex = (currentIndex + 1) % colors.length;
  block.style.setProperty('--theme', colors[nextIndex]);
}

// Function to resize block
function resizeBlock(block) {
  const currentTransform = block.style.transform || '';
  if (currentTransform.includes('scale')) {
    // Reset to normal size
    block.style.transform = currentTransform.replace(/scale\([^)]*\)/g, '');
  } else {
    // Make larger
    block.style.transform = currentTransform + ' scale(1.2)';
  }
}

// Function to setup event listeners for blocks (used for duplicated blocks)
function setupBlockEventListeners(block) {
  // Re-add info button functionality
  const infoBtn = block.querySelector('.block-info-btn');
  if (infoBtn) {
    infoBtn.onclick = (e) => {
      e.stopPropagation();
      const data = { name: block.dataset.blockType, type: block.dataset.blockType };
      showBlockInfoPopup(block, data);
    };
  }
  
  // Re-add delete button functionality
  const deleteBtn = block.querySelector('.delete-btn');
  if (deleteBtn) {
    deleteBtn.onclick = () => block.remove();
  }
  
  // Re-add context menu
  block.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    showBlockContextMenu(e, block);
  });
  
  // Make the block draggable
  makeBlockDraggable(block);
}