Product Name
Inspector Twin (formerly Inspector-BE)

Goal
Build a desktop Electron application that lets organisations create a digital twin of their physical + digital environment, run safe simulations (traffic, failures, misconfigs), optionally run authorised local security checks against user-provided containerised services, and generate reports.

Non-Goals (must enforce)
No external (outside of the app) attack tooling (no exploit payloads, no bruteforce modules, no stealth).
No network scanning outside the user’s local sandbox.
No automatic targeting of external IPs/domains by default.
No “drop malware” workflows.

If any “security checks” exist, they must be:
Executed only against explicitly launched local Docker/Podman lab stacks.
Executed only within the app

Tech Stack
Node.js + TypeScript
Electron (desktop shell)
Vite + React + TypeScript (renderer UI)
Zustand (state management)
React Flow (drag/drop topology canvas)
Monaco Editor (policy/config DSL editing)
SQLite via better-sqlite3 (local project storage)
Zod (schema validation)
Playwright (UI tests) + Vitest (unit tests)
dockerode (optional: manage local docker lab stacks)
reportlab alternative: generate reports via pdf-lib or Playwright print-to-PDF

Repository Layout (npm workspace)
Create a monorepo:
inspectortwin/
  package.json (workspaces)
  apps/
    desktop/                 # Electron main + preload + packaging
    renderer/                # React UI (Vite)
  packages/
    core-sim/                # Topology + simulation engine (pure TS)
    project-store/           # SQLite models, migrations, repo layer
    policy-dsl/              # Tiny DSL parser + validator for firewall/policies
    report-kit/              # report builder + PDF/JSON output
    lab-runtime/             # optional docker lab orchestration + local checks
    shared/                  # shared types, zod schemas
  docs/
  scripts/

Workspaces should build with npm install at root. The application should be able to run from a single 'run_dev.sh'. The application must be able to run on windows, linux and mac and should either be packaged with everything needed to avoid install, or be able to install on run without prior setup required.

App Capabilities (MVP v0.1)
1) Digital Twin Designer (Canvas)

Drag and drop nodes:
Router, Switch, Firewall, Modem/ISP, Server, Workstation, Mobile, IoT, “Tactical Data Link” (TDL), “Hacking Device” (ESP32/sniffer placeholder), Cloud Service.

Connect nodes with links:
Ethernet, Wi-Fi, WAN, VPN tunnel, Serial/TDL (abstract).

Each node has a property panel:
Name, role, OS, versions, tags, risk criticality

Interfaces (IP/subnet, ability to track and assess packets being sent etc..)
For firewall: allow/deny rules in a simple DSL

Each link has:
bandwidth, latency, loss %, jitter, “can fail” toggle

2) Simulation Engine (core-sim)

Must support:
Packet flow animation events (not raw packets, “logical packets”)
Full Routing (p4 etc...)
Firewall allow/deny
Failure injection (drop link, degrade link)
Basic metrics: latency estimate, reachability, “blast radius” impact
uploading external or custom software and firmware for routers and simulating correctly.
super lightweight ethical hacking tools for testing and assessing network security within the app

3) Scenarios (Runbook)
A “Scenario” is a reproducible simulation configuration:
Baseline traffic definitions (e.g., “Users -> App Server -> DB”)
Injected faults (link down, firewall block, DNS failure)

Attack simulations should run and be customisable, only to run locally within the environment, e.g.:
“Credential reuse event”
“Phishing compromise of workstation”
“Lateral movement attempt blocked by segmentation”
“Data exfil attempt detected”
These are not exploits; they’re state transitions + policy evaluation.

4) Safe Local Lab Testing 
Allow users to spin up local containers of their websites , databases or applications to be tested:
Example stacks: “Web app + DB”, “Reverse proxy + app”

Only from:
Local docker-compose.yml user selects, OR
Built-in safe templates (hello-world services)
OR localhost ports specified by the user.

5) Reporting

Generate:
Architecture summary (nodes/links)
Risk findings (misconfigs, weak policies)
Scenario results (pass/fail, timeline)

Output formats:
JSON (machine readable)
PDF (human report)
UX Requirements
Main navigation (left sidebar)

Projects
Twin Designer
Scenarios
Simulation Runner
Findings
Reports
Settings

Twin Designer screen
React Flow canvas

Node palette (left)
Properties panel (right)
Bottom bar: “Validate”, “Run Simulation”, “Export”

Simulation Runner
Choose scenario
“Run” button

Timeline events (packet flows, failures, policy blocks)
Metrics: reachability matrix + latency bars
“Generate report” button

Findings
List grouped by severity (Critical/High/Medium/Low/Info)
Each finding links to:
impacted nodes/links
suggested remediation text

Data Model (SQLite)
Tables:
projects(id, name, created_at, updated_at)
topologies(id, project_id, name, graph_json, created_at, updated_at)
scenarios(id, project_id, topology_id, name, scenario_json, created_at)
runs(id, scenario_id, started_at, finished_at, results_json, status)
findings(id, run_id, severity, title, description, evidence_json, remediation)
reports(id, run_id, path, created_at)
All JSON blobs must be validated with Zod schemas before save/load.

Core Simulation API (packages/core-sim)
Types
Node, Link, Graph
Policy (firewall rules)
Scenario (traffic + faults + events
RunResult (timeline + metrics + findings)

Required functions
validateGraph(graph): ValidationResult[]
simulate(graph, scenario, options): RunResult
computeBlastRadius(graph, compromisedNodeId): BlastRadiusResult
“Packet” abstraction
Simulate real packets. Use:
Flow { from, to, protocol, port?, rate, label }

Simulation computes:
allowed path?
predicted latency?
dropped due to policy/failure?
Firewall/Policy DSL (packages/policy-dsl)
Human-friendly DSL, example:
allow tcp from Users to WebApp port 443
deny any from Guests to Internal
allow dns from Any to DNS

Requirements:
Parse to AST
Validate references to node groups/tags
Compile to evaluation function used by core-sim
“Automated Hacking” Reframed Safely
Rename internally to Automated Security Checks.
It must be implemented as:
Misconfiguration simulation + policy linting + lab-only checks
Examples of allowed checks:
“Public service exposed without TLS”
“Admin interface reachable from Guest VLAN”
“Missing security headers in lab web service”
“Outdated dependency detected from manifest”

Codex must implement enforcement within the application:

Block any target host not in localhost, 127.0.0.1 or local network 192.168....

UI warnings and “Rules of Engagement” checkbox before running checks.
Electron Security Requirements
contextIsolation: true
nodeIntegration: false

Use preload bridge with explicit APIs only:
project storage calls
report generation
optional docker/lab orchestration

CSP headers in renderer
CLI + NPM Packaging (deliverables)
1) Desktop App
apps/desktop builds:
npm run dev launches Electron + Vite
npm run build packages for mac/win/linux via electron-builder

2) NPM Packages
Publishable packages (even if private):
@inspectortwin/core-sim
@inspectortwin/policy-dsl
@inspectortwin/report-kit

Build Commands
At repo root:
npm install
npm run dev (starts renderer + electron)
npm run test (vitest + playwright)
npm run lint
npm run build (packages + desktop)

Acceptance Criteria (Definition of Done)
Functional
User can create a project, build a topology, and save it.
User can define a scenario (traffic + at least one fault).
User can create the following full scenario (1.⁠ ⁠An attacker
2.⁠ ⁠Network Devices
3.⁠ ⁠Generating reports)

Simulation run produces:
timeline of events
reachability matrix
at least 3 finding types (policy block, single point of failure, exposed path)

Report generation outputs JSON + PDF.
App runs offline, no cloud dependency required.

Safety
No network operations against external IPs/domains by default.
Any “checks” limited to:
simulation OR docker lab network.
UI includes “Authorised Testing Only” notice + ROE gating before checks.

Quality
Unit tests for core-sim and policy-dsl
Minimal UI test: create topology → run scenario → generate report
Implementation Steps (Codex should follow)
Scaffold monorepo workspaces
Build shared types + zod schemas
Implement SQLite project-store
Build React Flow canvas + property panels
Implement policy-dsl parser + evaluator
Implement core-sim (routing + policy + failures)
Implement scenario editor + runner UI
Findings engine + report-kit (PDF + JSON)
Electron hardening + packaging

Tests + docs
Seed Content (include sample data)

Ship with 2 sample projects:
“SME Office + Cloud App”
“School Lab + Guest Wi-Fi Segmentation”

Each has 3 scenarios:
“ISP link failure”
“Guest network tries to reach internal admin panel (blocked)”
"An attacker is on the network"

Prompt Footer Codex Should Include in README

Inspector Twin is designed for simulation and authorised local testing only. Do not use it to target real systems without written permission. The app enforces local-only constraints by default.